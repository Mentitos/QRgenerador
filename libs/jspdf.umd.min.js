/**
 * jsPDF - Open-source JavaScript PDF library.
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 *
 * Authors:
 *   Manuel Dietrich <manuel.dietrich@gmail.com>
 *   James Hall <james@parall.ax>
 *   Arjun Mehta <arjun@arjunmehta.net>
 *   Andreas Weder <andreas.weder@gmail.com>
 *   and many more contributors
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jspdf = {}));
})(this, (function (exports) { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  /**
   * @license
   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * @license
   * Copyright (c) 2014 Norris Technologies LLC, norris-technologies.com
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */

  /**
   * jsPDF's Internal PubSub implementation.
   * @class
   * @name PubSub
   * @ignore
   */
  function PubSub(context) {
    var topics = {};

    this.subscribe = function (topic, callback) {
      if (!topics[topic]) {
        topics[topic] = [];
      }
      topics[topic].push(callback);
      return {
        topic: topic,
        callback: callback,
        dispose: function dispose() {
          return topics[topic].splice(topics[topic].indexOf(callback), 1);
        }
      };
    };

    this.publish = function (topic) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (topics[topic]) {
        topics[topic].forEach(function (callback) {
          callback.apply(context, args);
        });
      }
    };
  }

  /**
   * @license
   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * @license
   * Copyright (c) 2014 Norris Technologies LLC, norris-technologies.com
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */

  /**
   * Creates new jsPDF document object instance.
   * @class
   * @param {Object} [options] - Collection of settings initializing the jsPDF object
   * @param {string} [options.orientation=portrait] - Orientation of the documnet. 'portrait' or 'landscape' (or shortcuts 'p' or 'l')
   * @param {string} [options.unit=mm] - Unit of measurement. 'pt' (points), 'mm' (Default), 'cm', 'in'
   * @param {string|Array} [options.format=a4] - The format of the first page. Can be 'a3', 'a4' (Default), 'a5', 'a6', 'b3', 'b4', 'b5', 'b6', 'legal', 'letter' or an array in the form [width, height]
   * @param {boolean} [options.compress=false] - If true, the content will be compressed (useful for images)
   * @param {number} [options.precision=2] - Precision of numbers in output.
   * @param {number} [options.filters] -
   * @param {boolean} [options.userUnit=1.0] -
   * @param {string} [options.encryption] -
   * @param {Object} [options.hotfixes] -
   * @returns {jsPDF}
   * @name jsPDF
   */
  function jsPDF(options) {
    var global = typeof window !== 'undefined' && window.window === window ? window : typeof self !== 'undefined' && self.self === self ? self : typeof global !== 'undefined' && global.global === global ? global : undefined;

    var _options = {};
    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      _options = options;
    }

    var orientation = _options.orientation || 'p';
    var unit = _options.unit || 'mm';
    var format = _options.format || 'a4';
    var compress = _options.compress || false;
    var hotfixes = _options.hotfixes || [];
    var precision = _options.precision || 2;
    var userUnit = _options.userUnit || 1.0;
    var defaultPathGenerator = _options.defaultPathGenerator || "jsPDF";

    var API = {
      internal: {},
      __private__: {}
    };

    API.__private__.PubSub = PubSub;
    var pubSub = new PubSub(API);

    Object.defineProperty(API, 'events', {
      value: pubSub,
      writable: true,
      enumerable: true,
      configurable: true
    });

    API.internal = {
      'pdfEscape': pdfEscape,
      'getFont': getFont,
      'getFontList': getFontList,
      'addFont': addFont,
      'addFonts': addFonts,
      'putTotalPages': putTotalPages,
      'addImage': addImage,
      'getImageProperties': getImageProperties,
      'getXObjectKey': getXObjectKey,
      'getXObjects': getXObjects,
      'getColor': getColor,
      'getFillColor': getFillColor,
      'getLineColor': getLineColor,
      'getTextColor': getTextColor,
      'setColor': setColor,
      'setFillColor': setFillColor,
      'setLineColor': setLineColor,
      'setTextColor': setTextColor,
      'getDrawColor': getDrawColor,
      'setDrawColor': setDrawColor,
      'getLineWidth': getLineWidth,
      'setLineWidth': setLineWidth,
      'getLineCap': getLineCap,
      'setLineCap': setLineCap,
      'getLineJoin': getLineJoin,
      'setLineJoin': setLineJoin,
      'getMiterLimit': getMiterLimit,
      'setMiterLimit': setMiterLimit,
      'getDashPattern': getDashPattern,
      'setDashPattern': setDashPattern,
      'getFont': getFont,
      'setFont': setFont,
      'getFontSize': getFontSize,
      'setFontSize': setFontSize,
      'getCharSpace': getCharSpace,
      'setCharSpace': setCharSpace,
      'getTextRenderingMode': getTextRenderingMode,
      'setTextRenderingMode': setTextRenderingMode,
      'getTextRise': getTextRise,
      'setTextRise': setTextRise,
      'getTextIndent': getTextIndent,
      'setTextIndent': setTextIndent,
      'getTextKerning': getTextKerning,
      'setTextKerning': setTextKerning,
      'getTextWordSpacing': getTextWordSpacing,
      'setTextWordSpacing': setTextWordSpacing,
      'getTextLineHeight': getTextLineHeight,
      'setTextLineHeight': setTextLineHeight,
      'getTextBaseline': getTextBaseline,
      'setTextBaseline': setTextBaseline,
      'getTextAlign': getTextAlign,
      'setTextAlign': setTextAlign,
      'getTextDirection': getTextDirection,
      'setTextDirection': setTextDirection,
      'getTextScale': getTextScale,
      'setTextScale': setTextScale,
      'getTextMatrix': getTextMatrix,
      'setTextMatrix': setTextMatrix,
      'getTextTransform': getTextTransform,
      'setTextTransform': setTextTransform,
      'getTextShadow': getTextShadow,
      'setTextShadow': setTextShadow,
      'getTextStroke': getTextStroke,
      'setTextStroke': setTextStroke,
      'getTextStrokeColor': getTextStrokeColor,
      'setTextStrokeColor': setTextStrokeColor,
      'getTextStrokeWidth': getTextStrokeWidth,
      'setTextStrokeWidth': setTextStrokeWidth,
      'getTextStrokeOpacity': getTextStrokeOpacity,
      'setTextStrokeOpacity': setTextStrokeOpacity,
      'getTextStrokeDasharray': getTextStrokeDasharray,
      'setTextStrokeDasharray': setTextStrokeDasharray,
      'getTextStrokeDashoffset': getTextStrokeDashoffset,
      'setTextStrokeDashoffset': setTextStrokeDashoffset,
      'getTextStrokeLinecap': getTextStrokeLinecap,
      'setTextStrokeLinecap': setTextStrokeLinecap,
      'getTextStrokeLinejoin': getTextStrokeLinejoin,
      'setTextStrokeLinejoin': setTextStrokeLinejoin,
      'getTextStrokeMiterlimit': getTextStrokeMiterlimit,
      'setMiterLimit': setMiterLimit
    };

    //this is only used for the data url
    var getArrayBuffer = function getArrayBuffer(data) {
      var len = data.length,
          ab = new ArrayBuffer(len),
          u8 = new Uint8Array(ab);

      while (len--) {
        u8[len] = data.charCodeAt(len);
      }
      return ab;
    };

    var getBlob = function getBlob(data) {
      return new Blob([getArrayBuffer(data)], {
        type: "application/pdf"
      });
    };
    /**
     * @name setProperties
     * @function
     * @param {Object} properties
     * @returns {jsPDF}
     */
    API.setProperties = function (properties) {
      // copying only those properties passed in.
      if (typeof properties.title !== "undefined") {
        doc.info.title = properties.title;
      }
      if (typeof properties.subject !== "undefined") {
        doc.info.subject = properties.subject;
      }
      if (typeof properties.author !== "undefined") {
        doc.info.author = properties.author;
      }
      if (typeof properties.keywords !== "undefined") {
        doc.info.keywords = properties.keywords;
      }
      if (typeof properties.creator !== "undefined") {
        doc.info.creator = properties.creator;
      }
      return this;
    };

    /**
     * @name save
     * @function
     * @param {string} filename The name of the file to be saved
     * @param {Object} options
     * @returns {jsPDF}
     */
    API.save = function (filename, options) {
      filename = filename || "generated.pdf";

      options = options || {};
      options.returnPromise = options.returnPromise || false;

      if (options.returnPromise) {
        return new Promise(function (resolve, reject) {
          try {
            var data = output('datauristring');
            var blob = getBlob(data);
            saveAs(blob, filename);
            resolve();
          } catch (e) {
            reject(e.message);
          }
        });
      }

      var data = output('datauristring');
      var blob = getBlob(data);
      saveAs(blob, filename);
      return this;
    };

    // applying plugins (more methods) ON TOP of built-in API.
    // N.B. this is a departure from 1.x plugin system.
    for (var plugin in jsPDF.API) {
      if (jsPDF.API.hasOwnProperty(plugin)) {
        if (plugin === "events") {
          console.warn("The events plugin is no longer supported!");
        } else {
          API[plugin] = jsPDF.API[plugin];
        }
      }
    }

    var doc = {
      internal: {
        pdfEscape: pdfEscape,
        getFont: getFont,
        getFontList: getFontList,
        addFont: addFont,
        addFonts: addFonts,
        putTotalPages: putTotalPages,
        addImage: addImage,
        getImageProperties: getImageProperties,
        getXObjectKey: getXObjectKey,
        getXObjects: getXObjects,
        getColor: getColor,
        getFillColor: getFillColor,
        getLineColor: getLineColor,
        getTextColor: getTextColor,
        setColor: setColor,
        setFillColor: setFillColor,
        setLineColor: setLineColor,
        setTextColor: setTextColor,
        getDrawColor: getDrawColor,
        setDrawColor: setDrawColor,
        getLineWidth: getLineWidth,
        setLineWidth: setLineWidth,
        getLineCap: getLineCap,
        setLineCap: setLineCap,
        getLineJoin: getLineJoin,
        setLineJoin: setLineJoin,
        getMiterLimit: getMiterLimit,
        setMiterLimit: setMiterLimit,
        getDashPattern: getDashPattern,
        setDashPattern: setDashPattern,
        getFont: getFont,
        setFont: setFont,
        getFontSize: getFontSize,
        setFontSize: setFontSize,
        getCharSpace: getCharSpace,
        setCharSpace: setCharSpace,
        getTextRenderingMode: getTextRenderingMode,
        setTextRenderingMode: setTextRenderingMode,
        getTextRise: getTextRise,
        setTextRise: setTextRise,
        getTextIndent: getTextIndent,
        setTextIndent: setTextIndent,
        getTextKerning: getTextKerning,
        setTextKerning: setTextKerning,
        getTextWordSpacing: getTextWordSpacing,
        setTextWordSpacing: setTextWordSpacing,
        getTextLineHeight: getTextLineHeight,
        setTextLineHeight: setTextLineHeight,
        getTextBaseline: getTextBaseline,
        setTextBaseline: setTextBaseline,
        getTextAlign: getTextAlign,
        setTextAlign: setTextAlign,
        getTextDirection: getTextDirection,
        setTextDirection: setTextDirection,
        getTextScale: getTextScale,
        setTextScale: setTextScale,
        getTextMatrix: getTextMatrix,
        setTextMatrix: setTextMatrix,
        getTextTransform: getTextTransform,
        setTextTransform: setTextTransform,
        getTextShadow: getTextShadow,
        setTextShadow: setTextShadow,
        getTextStroke: getTextStroke,
        setTextStroke: setTextStroke,
        getTextStrokeColor: getTextStrokeColor,
        setTextStrokeColor: setTextStrokeColor,
        getTextStrokeWidth: getTextStrokeWidth,
        setTextStrokeWidth: setTextStrokeWidth,
        getTextStrokeOpacity: getTextStrokeOpacity,
        setTextStrokeOpacity: setTextStrokeOpacity,
        getTextStrokeDasharray: getTextStrokeDasharray,
        setTextStrokeDasharray: setTextStrokeDasharray,
        getTextStrokeDashoffset: getTextStrokeDashoffset,
        setTextStrokeDashoffset: setTextStrokeDashoffset,
        getTextStrokeLinecap: getTextStrokeLinecap,
        setTextStrokeLinecap: setTextStrokeLinecap,
        getTextStrokeLinejoin: getTextStrokeLinejoin,
        setTextStrokeLinejoin: setTextStrokeLinejoin,
        getTextStrokeMiterlimit: getTextStrokeMiterlimit,
        setMiterLimit: setMiterLimit
      },
      __private__: {},
      info: {
        title: undefined,
        subject: undefined,
        author: undefined,
        keywords: undefined,
        creator: undefined
      }
    };

    Object.defineProperty(doc, 'internal', {
      value: API.internal,
      writable: false,
      enumerable: false,
      configurable: false
    });

    Object.defineProperty(doc, '__private__', {
      value: API.__private__,
      writable: true,
      enumerable: false,
      configurable: false
    });

    Object.defineProperty(doc, 'info', {
      value: doc.info,
      writable: true,
      enumerable: false,
      configurable: false
    });

    for (var method in API) {
      if (API.hasOwnProperty(method)) {
        doc[method] = API[method];
      }
    }

    return doc;
  }

  /**
   * @name API
   * @class
   */
  jsPDF.API = {
    events: {}
  };

  var version = "2.5.1";

  var jsPDF$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    jsPDF: jsPDF,
    PubSub: PubSub,
    API: jsPDF.API,
    version: version
  });

  exports.jsPDF = jsPDF;
  exports.PubSub = PubSub;
  exports.API = jsPDF.API;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=jspdf.umd.min.js.map
